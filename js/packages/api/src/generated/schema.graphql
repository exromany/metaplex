### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AmountRange {
  amount: BN
  length: BN
}

type AuctionData {
  """
  Gap time is the amount of time in slots after the previous bid at which the auction ends.
  """
  auctionGap: BN

  """Pubkey of the authority with permission to modify this auction."""
  authority: PublicKey

  """Used for precalculation on the front end, not a backend key"""
  bidRedemptionKey: PublicKey

  """Auction Bids, each user may have one bid open at a time."""
  bidState: BidState

  """End time is the cut-off point that the auction is forced to end by."""
  endAuctionAt: BN

  """Slot time the auction was officially ended by."""
  endedAt: BN

  """
  The time the last bid was placed, used to keep track of auction timing.
  """
  lastBid: BN

  """Minimum price for any bid to meet."""
  priceFloor: PriceFloor

  """The state the auction is in, whether it has started or ended."""
  state: AuctionState

  """Token mint for the SPL token being used to bid"""
  tokenMint: PublicKey
}

type AuctionDataExtended {
  gapTickSizePercentage: Int
  tickSize: BN
  totalUncancelledBids: BN
}

type AuctionManagerV1 {
  key: MetaplexKey
}

type AuctionManagerV2 {
  key: MetaplexKey
}

enum AuctionState {
  Created
  Ended
  Started
}

"""GraphQL representation of BigNumber"""
scalar BN

type Bid {
  amount: BN
  key: PublicKey
}

type BidRedemptionTicket {
  key: MetaplexKey
}

type BidState {
  bids: [Bid]
  max: BN
  type: BidStateType
}

enum BidStateType {
  EnglishAuction
  OpenEdition
}

type BidderMetadata {
  """Relationship with the auction this bid was placed on."""
  auctionPubkey: PublicKey

  """Relationship with the bidder who's metadata this covers."""
  bidderPubkey: PublicKey

  """
  Whether the last bid the user made was cancelled. This should also be enough to know if the
  user is a winner, as if cancelled it implies previous bids were also cancelled.
  """
  cancelled: Boolean

  """Amount that the user bid"""
  lastBid: BN

  """Tracks the last time this user bid."""
  lastBidTimestamp: BN
}

type BidderPot {
  auctionAct: PublicKey
  bidderAct: PublicKey

  """Points at actual pot that is a token account"""
  bidderPot: PublicKey
  emptied: Boolean
}

scalar Buffer

type Creator {
  address: PublicKey
  share: Int
  verified: Boolean
}

type Data {
  creators: [Creator]
  name: String
  sellerFeeBasisPoints: Int
  symbol: String
  uri: String
}

type Edition {
  """
  Starting at 0 for master record, this is incremented for each edition minted
  """
  edition: BN
  key: MetadataKey

  """Points at MasterEdition struct"""
  parent: PublicKey
}

union MasterEdition = MasterEditionV1 | MasterEditionV2

type MasterEditionV1 {
  key: MetadataKey
  maxSupply: BN
  oneTimePrintingAuthorizationMint: PublicKey
  printingMint: PublicKey
  supply: BN
}

type MasterEditionV2 {
  key: MetadataKey
  maxSupply: BN
  supply: BN
}

type Metadata {
  data: Data
  edition: PublicKey
  isMutable: Boolean
  key: MetadataKey
  masterEdition: PublicKey
  mint: PublicKey
  primarySaleHappened: Boolean
  updateAuthority: PublicKey
}

enum MetadataKey {
  EditionMarker
  EditionV1
  MasterEditionV1
  MasterEditionV2
  MetadataV1
  Uninitialized
}

enum MetaplexKey {
  AuctionManagerV1
  AuctionManagerV2
  AuctionWinnerTokenTypeTrackerV1
  BidRedemptionTicketV1
  BidRedemptionTicketV2
  OriginalAuthorityLookupV1
  PayoutTicketV1
  PrizeTrackingTicketV1
  SafetyDepositConfigV1
  SafetyDepositValidationTicketV1
  StoreV1
  Uninitialized
  WhitelistedCreatorV1
}

enum NonWinningConstraint {
  GivenForBidPrice
  GivenForFixedPrice
  NoParticipationPrize
}

type ParticipationConfigV2 {
  fixedPrice: BN
  nonWinningConstraint: NonWinningConstraint
  winnerConstraint: WinningConstraint
}

type ParticipationStateV2 {
  collectedToAcceptPayment: BN
}

type PayoutTicket {
  amountPaid: BN
  key: MetaplexKey
  recipient: PublicKey
}

type PriceFloor {
  """
  It's an array of 32 u8s, when minimum, only first 8 are used (a u64), when blinded price, the entire
  thing is a hash and not actually a public key, and none is all zeroes
  """
  hash: Uint8Array
  minPrice: BN
  type: PriceFloorType
}

enum PriceFloorType {
  BlindedPrice
  Minimum
  None
}

type PrizeTrackingTicket {
  expectedRedemptions: BN
  key: MetaplexKey
  metadata: PublicKey
  redemptions: BN
  supplySnapshot: BN
}

scalar PublicKey

type Query {
  artworks(creatorId: String, storeId: String!): [Metadata]
  artworksCount: Int
  creator(creatorId: String!, storeId: String!): WhitelistedCreator
  creators(storeId: String!): [WhitelistedCreator]
  creatorsCount: Int
  store(storeId: String!): Store
  storesCount: Int
}

type SafetyDepositBox {
  """
  Each token type in a vault has it's own box that contains it's mint and a look-back
  """
  key: VaultKey
  order: Int @deprecated(reason: "The order in the array of registries")

  """Account that stores the tokens under management"""
  store: PublicKey

  """This particular token's mint"""
  tokenMint: PublicKey
  vault: PublicKey @deprecated(reason: "VaultKey pointing to the parent vault")
}

type SafetyDepositConfig {
  amountRanges: [AmountRange]
  amountType: TupleNumericType
  auctionManager: PublicKey
  key: MetaplexKey
  lengthType: TupleNumericType
  order: BN
  participationConfig: ParticipationConfigV2
  participationState: ParticipationStateV2
  winningConfigType: WinningConfigType
}

type Store {
  auctionProgram: PublicKey
  key: MetaplexKey
  public: Boolean
  tokenMetadataProgram: PublicKey
  tokenProgram: PublicKey
  tokenVaultProgram: PublicKey
}

enum TupleNumericType {
  U8
  U16
  U32
  U64
}

scalar Uint8Array

type Vault {
  """Can authority mint more shares from fraction_mint after activation"""
  allowFurtherShareCreation: Boolean

  """Authority who can make changes to the vault"""
  authority: PublicKey

  """Mint that produces the fractional shares"""
  fractionMint: PublicKey

  """treasury where fractional shares are held for redemption by authority"""
  fractionTreasury: PublicKey
  key: VaultKey

  """
  Once combination happens, we copy price per share to vault so that if something nefarious happens
  to external price account, like price change, we still have the math 'saved' for use in our calcs
  """
  lockedPricePerShare: BN

  """
  Must point at an ExternalPriceAccount, which gives permission and price for buyout.
  """
  pricingLookupAddress: PublicKey

  """
  treasury where monies are held for fractional share holders to redeem(burn) shares once buyout is made
  """
  redeemTreasury: PublicKey
  state: VaultState
  tokenProgram: PublicKey @deprecated(reason: "Store token program used")

  """
  In inactive state, we use this to set the order key on Safety Deposit Boxes being added and
  then we increment it and save so the next safety deposit box gets the next number.
  In the Combined state during token redemption by authority, we use it as a decrementing counter each time
  The authority of the vault withdrawals a Safety Deposit contents to count down how many
  are left to be opened and closed down. Once this hits zero, and the fraction mint has zero shares,
  then we can deactivate the vault.
  """
  tokenTypeCount: Int
}

enum VaultKey {
  ExternalPriceAccountV1
  SafetyDepositBoxV1
  Uninitialized
  VaultV1
}

enum VaultState {
  Active
  Combined
  Deactivated
  Inactive
}

type WhitelistedCreator {
  activated: Boolean
  address: PublicKey
  key: MetaplexKey
}

enum WinningConfigType {
  FullRightsTransfer
  Participation
  PrintingV1
  PrintingV2
  TokenOnlyTransfer
}

enum WinningConstraint {
  NoParticipationPrize
  ParticipationPrizeGiven
}
